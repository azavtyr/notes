{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>IMPORTANT NOTICE</p> <p>This is a personal documentation. It\u2019s where I capture my learning process and document how I approach problems. Some content comes from official sources, some from books, some from my own research, and some from hands-on experience - all tailored to my setup and thinking. If you find it useful, that\u2019s great.</p> <p>You might wonder why I share this if it\u2019s mainly for myself. Sharing my notes keeps me organized and serves as a backup of my work. Plus, it may help others who find something useful here. But don\u2019t expect a polished manual \u2014 this is my personal tech journal, not a comprehensive guide.</p> <p>If you landed here from my portfolio \u2014 welcome again.</p> <p>This is the technical heart of my site, where I focus on Linux, networking, virtualization, sysadmin tasks, programming, and everything in between. It\u2019s where I keep detailed notes on what I\u2019m learning, experimenting with, breaking, fixing, and rebuilding. Over time, it\u2019s become my space for organizing configs, setups, and insights that future me will definitely need.</p> <p>This isn\u2019t polished or SEO-focused \u2014 it\u2019s simply my way of keeping track of the complex stuff in a way that makes sense to me.</p> <p>Treat it like an open notebook. Poke around. Steal configs, setups. Or just see how someone else learns by doing.</p>"},{"location":"docker/","title":"Docker","text":"<p>Docker is a containerization platform by which you can have an isolated dev environment for building, sharing, and running applications with all its dependencies.</p>"},{"location":"docker/#key-components-of-docker","title":"Key Components of Docker","text":"<ul> <li>Docker Engine is the core of Docker, that handles creation and management of containers.</li> <li>Docker Image is a snapshot of your application along with all of its dependencies. It can be used to create and run multiple containers.</li> <li>Container is your actual application with all its dependencies running in the real world.</li> <li>Dockerfile is an instruction file that describes the steps to create a Docker Image quickly.</li> </ul>"},{"location":"docker/#docker-notes","title":"Docker Notes","text":"<p>Below is a collection of notes on specific Docker topics:</p>"},{"location":"docker/#docker-networking","title":"Docker Networking","text":"<ul> <li>Docker Network Overview</li> <li>Docker Bridge Networking</li> <li>Docker IPvLAN Networking</li> <li>Docker None Network Driver</li> <li>Docker Overlay Networking</li> </ul>"},{"location":"docker/#docker-storage","title":"Docker Storage","text":"<ul> <li>Docker Volumes</li> </ul>"},{"location":"docker/#general-concepts","title":"General Concepts","text":"<ul> <li>Docker Image Basics</li> <li>What is Docker Compose?</li> </ul>"},{"location":"docker/docker-bridge/","title":"Docker Bridge","text":"<p>The bridge driver creates a private network for containers on the host machine. When you start Docker, it automatically creates a default bridge network on the host machine, represented by a virtual interface (<code>docker0</code>), which started containers connect to unless otherwise specified. Containers on the same bridge network can talk to each other via IP addresses. However, if you want to access a service (like a webserver) running in a container from your host machine, you'll need to expose ports to the host.</p>"},{"location":"docker/docker-bridge/#user-defined-custom-bridge","title":"User Defined Custom Bridge","text":"<p>Uses the same bridge driver, but you define it instead. There are some advantages to using this type of network:</p> <ul> <li>It provides automatic DNS resolution between containers, which means that containers can resolve each other by name or alias.</li> <li>User Defined Bridges provide better isolation. Only containers connected to the same user-defined bridge can communicate with each other.</li> </ul>"},{"location":"docker/docker-bridge/#create-a-user-defined-bridge","title":"Create a user-defined bridge","text":"<pre><code>docker network create custombridge\n</code></pre>"},{"location":"docker/docker-bridge/#create-a-container-connected-to-the-user-defined-bridge","title":"Create a container connected to the user-defined bridge","text":"<pre><code>docker run -itd --rm --network custombridge alpine\n</code></pre>"},{"location":"docker/docker-host-driver/","title":"Docker Host Driver","text":"<p>The host driver removes isolation between the container and the Docker host, and directly connects to the host's network.</p> <ul> <li>The container doesn't get its own IP address, it uses the host's IP.</li> <li>There is no need to expose ports, any service running in the container is directly accessible via the host's ports.</li> </ul> <p>Caution</p> <ul> <li>This driver removes network isolation.</li> <li>Not supported or not fully supported on Mac/Windows. (Only Linux)</li> </ul>"},{"location":"docker/docker-host-driver/#create-a-container-connected-to-host-network","title":"Create a container connected to host network","text":"<pre><code>docker run -itd --rm --network host --name webserver nginx\n</code></pre> <p>Open a web-browser and type the host's IP address in the URL bar.</p>"},{"location":"docker/docker-image/","title":"Docker Image","text":"<p>Docker Images are built using a Dockerfile with multiple layers, each representing filesystem changes. Layers are stacked on top of each other, forming a complete image.</p> <p>Layers are cached and can be reused. If layer already exists from a previous build, Docker will not create the new one, but instead will use cached layer, which significantly increases speed of the building process.</p>"},{"location":"docker/docker-image/#example-of-image-layers","title":"Example of Image Layers","text":"<p>This Dockerfile contains four commands. Commands that modify the filesystem create a new layer.</p> <pre><code>FROM debian:latest\n\nRUN apt update &amp;&amp; apt install iputils-ping -y\n\nCMD [\"ping\", \"-c 3\", \"8.8.8.8\"]\n</code></pre> <ul> <li><code>FROM</code>, and <code>RUN</code> instructions, each create a new read-only layer.</li> <li>The <code>CMD</code> instruction only modifies the image's metadata, which doesn't produce an image layer.</li> </ul>"},{"location":"docker/docker-image/#build-a-docker-image","title":"Build a Docker Image","text":"<p><code>docker image build -t my_image .</code></p>"},{"location":"docker/docker-image/#writable-container-layer","title":"Writable Container Layer","text":"<p>When you create a new container, you add a new writable layer on top of the other layers. All changes made within a running container, such as writing new files, deleting or modifying existing ones, are written to this writable container layer. When the container is deleted, the writable layer is also deleted.</p>"},{"location":"docker/docker-image/#union-filesystem","title":"Union Filesystem","text":"<p>Docker uses union filesystem to create a single unified view of all layers, which are stacked on top of each other. When the container starts, it sees a unified filesystem, which contains all of underlying layers.</p> <p>When the union filesystem is created, in addition to the image layers, a directory is created specifically for the running container. This allows the container to make filesystem changes while allowing the original image layers to remain untouched. This enables you to run multiple containers from the same underlying image.</p>"},{"location":"docker/docker-image/#references","title":"References","text":"<ul> <li>https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/</li> <li>https://useful.codes/understanding-image-layers-and-caching-in-docker/</li> <li>https://docs.docker.com/engine/storage/drivers/</li> </ul>"},{"location":"docker/docker-ipvlan/","title":"Docker IPvlan","text":"<p>IPvlan network allows the host machine to share the MAC address with containers. So all containers MAC address will match the host's one, but they all will have different IP addresses and appear as physical devices on home network.</p>"},{"location":"docker/docker-ipvlan/#create-a-ipvlan","title":"Create a IPvlan","text":"<pre><code>docker network create -d ipvlan \\\n    --subnet=192.168.0.0/24 \\\n    --gateway=192.168.0.1 \\\n    -o parent=eth0 customipvlan\n</code></pre>"},{"location":"docker/docker-ipvlan/#create-a-container-connected-to-ipvlan","title":"Create a container connected to IPvlan","text":"<pre><code>docker run -itd --rm --network customipvlan --ip 192.168.0.200 nginx\n</code></pre> <p>Important</p> <p>As with Macvlan, you must manually assign an IP to each container, if you don't assign it, Docker will automatically assign one from the subnet, which may create a conflict with another device already using that IP on the network.</p>"},{"location":"docker/docker-macvlan/","title":"Docker Macvlan","text":"<p>Macvlan network allows to assign a MAC address to a container, making it appear as a physical device on my home network.</p> <ul> <li>The container gets its own IP address from the physical network's subnet.</li> <li>Other devices on the local network can reach the container directly.</li> </ul>"},{"location":"docker/docker-macvlan/#downsides","title":"Downsides","text":"<ul> <li>Physical network interface must support promiscuous mode.</li> <li>Not well supported on Mac/Windows.</li> </ul>"},{"location":"docker/docker-macvlan/#create-a-macvlan-network","title":"Create a Macvlan network","text":"<pre><code>docker network create -d macvlan \\\n    --subnet 192.168.0.0/24 \\\n    --gateway 192.168.0.1 \\\n    -o parent=eth0 custommacvlan\n</code></pre>"},{"location":"docker/docker-macvlan/#create-a-container-connected-to-macvlan","title":"Create a container connected to macvlan","text":"<pre><code>docker run -itd --rm --network custommacvlan --ip 192.168.0.200 nginx\n</code></pre> <p>Important</p> <p>You must manually assign an IP to each container, if you don't assign it, Docker will automatically assign one from the subnet, which may create a conflict with another device already using that IP on the network.</p>"},{"location":"docker/docker-network/","title":"Docker Network","text":"<p>Docker networking allows containers to communicate with each other and external services. It provides the ability to isolate, secure, and scale applications. Docker's networking system is pluggable, which means you can choose the right tool for the job. There are several built-in drivers:</p> <ul> <li><code>bridge</code></li> <li><code>host</code></li> <li><code>macvlan</code></li> <li><code>ipvlan</code></li> <li><code>none</code></li> <li><code>overlay</code></li> </ul> <p>Note</p> <p>Optional: A container may be connected to different types of networks. For example, an IPvlan network to provide internet access and a bridge network for access to local services.</p>"},{"location":"docker/docker-network/#list-all-networks","title":"List all networks","text":"<p><code>docker network ls</code></p>"},{"location":"docker/docker-network/#connect-a-container-to-a-network","title":"Connect a container to a network","text":"<p><code>docker network connect my_network my_container</code></p>"},{"location":"docker/docker-network/#disconnect-a-container-from-a-network","title":"Disconnect a container from a network","text":"<p><code>docker network disconnect my_network my_container</code></p>"},{"location":"docker/docker-network/#exposing-ports","title":"Exposing Ports","text":"<p><code>docker run -itd --name my_container -p 80:80 my_image</code></p>"},{"location":"docker/docker-network/#inspect-a-specific-network","title":"Inspect a specific network","text":"<p><code>docker network inspect my_network</code></p>"},{"location":"docker/docker-none-driver/","title":"Docker None Driver","text":"<p>None driver completely isolates a container from the host and other containers.</p>"},{"location":"docker/docker-none-driver/#create-a-container-connected-to-none","title":"Create a container connected to none","text":"<pre><code>docker run -itd --rm --network none alpine\n</code></pre>"},{"location":"docker/docker-overlay/","title":"Docker Overlay","text":"<p>Overlay driver creates a network that connects multiple Docker hosts, useful for Docker Swarm mode.</p>"},{"location":"docker/docker-volumes/","title":"Docker Volumes","text":"<p>Docker volumes are persistent data stores for containers, providing a way to store and manage data independently of a container's lifecycle. Unlike writing data directly to a container's writable layer, volumes do not increase the container's size, making them a preferred choice for data persistence. Volumes can be mounted into multiple containers simultaneously, enabling data sharing.</p>"},{"location":"docker/docker-volumes/#key-behaviors","title":"Key Behaviors","text":"<ul> <li>Named vs. Anonymous Volumes: Volumes can be named (user-defined) or anonymous (Docker assigns a random unique name). Named volumes are explicitly created and reusable, while anonymous volumes are not automatically shared or reused between containers.</li> <li>Persistence: When a container is destroyed, its writable layer is lost, but data in both named and anonymous volumes persists unless the container is created with the --rm flag, which removes anonymous volumes upon container removal.</li> <li>Non-Empty Volume Mounts: If you mount a non-empty volume into a container's directory, existing files or directories in that container path are not deleted but become inaccessible, hidden by the volume's contents.</li> <li>Empty Volume Mounts: If you mount an empty volume into a container directory containing files or directories, those files are copied into the volume by default. If the specified volume does not exist, Docker creates an empty volume automatically.</li> </ul>"},{"location":"docker/docker-volumes/#docker-volume-commands","title":"Docker Volume Commands","text":"<p>Here are common commands for managing Docker volumes:</p>"},{"location":"docker/docker-volumes/#create-a-volume","title":"Create a Volume","text":"<pre><code>docker volume create myvol\n</code></pre>"},{"location":"docker/docker-volumes/#remove-a-volume","title":"Remove a Volume","text":"<pre><code>docker volume rm myvol\n</code></pre>"},{"location":"docker/docker-volumes/#list-volumes","title":"List Volumes","text":"<pre><code>docker volume ls\n</code></pre>"},{"location":"docker/docker-volumes/#inspect-a-volume","title":"Inspect a Volume","text":"<pre><code>docker volume inspect myvol\n</code></pre>"},{"location":"docker/docker-volumes/#mount-a-volume","title":"Mount a Volume","text":"<pre><code>docker run -it --mount type=volume,src=myvol,dst=/mount/path ubuntu\n</code></pre> <p>Or,</p> <pre><code>docker run -it -v myvol:/mount/path ubuntu\n</code></pre> <p>For an anonymous volume, omit the <code>src</code> field (with <code>--mount</code>) or the volume name (with <code>-v</code>):</p> <pre><code>docker run -it --mount type=volume,dst=/mount/path ubuntu\n</code></pre> <p>Or,</p> <pre><code>docker run -it -v /mount/path ubuntu\n</code></pre> <p>To create a container with an anonymous volume that is removed when the container is deleted:</p> <pre><code>docker run -it --rm --mount type=volume,dst=/mount/path ubuntu\n</code></pre>"},{"location":"docker/what-is-docker-compose/","title":"Docker Compose","text":"<p>Docker Compose is a tool that allows you to run multiple containers with a single configuration file.</p> <p>The <code>docker-compose.yml</code> is the config file that defines all the services and parameters for containers to apply and run.</p>"},{"location":"docker/what-is-docker-compose/#explaining-docker-composeyml","title":"Explaining docker-compose.yml","text":"<pre><code>---\nversion: '3' # Compose file format version\n\nservices: # Defines all services / containers\n  service-name: # Custom name\n    image: # Docker image to build a container\n    volumes: # Mount host directories as data volumes\n    ports: # Expose ports to host\n    environment: # Add environment variables\n\nnetworks: # Networks for services to connect\nvolumes: # Define shared data volumes\n</code></pre>"},{"location":"homelab/","title":"Homelab","text":""},{"location":"homelab/#notes","title":"Notes","text":"<ul> <li>Nginx Proxy Manager Setup</li> <li>Pi-hole Setup with Docker Compose and Unbound</li> </ul>"},{"location":"homelab/gitea-setup/","title":"Setup Gitea with Docker","text":"<p>This guide walks through the process of setting up Gitea, a lightweight self-hosted Git service, using Docker and optionally securing it with Nginx Proxy Manager for a custom domain and SSL.</p>"},{"location":"homelab/gitea-setup/#prepare-the-project-directory","title":"Prepare the Project Directory","text":"<p>First, create a directory:</p> <pre><code>mkdir gitea\ncd gitea\n</code></pre>"},{"location":"homelab/gitea-setup/#docker-compose-setup","title":"Docker Compose Setup","text":"<p>Create a docker-compose.yml file:</p> <pre><code>---\nservices:\n  server:\n    image: docker.gitea.com/gitea:1.24.2\n    container_name: gitea\n    environment:\n      - USER_UID=1000\n      - USER_GID=1000\n    restart: unless-stopped\n    networks:\n      - proxy\n    volumes:\n      - gitea-data:/data\n      - /etc/timezone:/etc/timezone:ro\n      - /etc/localtime:/etc/localtime:ro\n\nvolumes:\n  gitea-data:\n\nnetworks:\n  proxy:\n    external: true\n</code></pre>"},{"location":"homelab/gitea-setup/#ssl-via-nginx-proxy-manager-optional","title":"SSL via Nginx Proxy Manager (Optional)","text":"<p>If you'd like to access Gitea via a custom domain like <code>git.yourdomain.com</code> and secure it with HTTPS, follow these steps:</p> <ol> <li>Access the Nginx Proxy Manager dashboard</li> <li>Navigate to Proxy Hosts and click Add Proxy Host</li> <li>Enter the following details:<ul> <li>Domain: <code>git.yourdomain.com</code></li> <li>Forward Hostname / IP: <code>gitea</code></li> <li>Forward Port: <code>3000</code></li> </ul> </li> <li>Under the SSL tab:<ul> <li>Choose the existing certificate from the dropdown</li> <li>Enable Force SSL and optionally HTTP/2.</li> </ul> </li> </ol> <p>Save the configuration.</p>"},{"location":"homelab/gitea-setup/#complete-gitea-initial-setup-via-browser","title":"Complete Gitea Initial Setup via Browser","text":"<ol> <li>Open your browser and navigate to: <code>https://git.yourdomain.com</code></li> <li>The Gitea setup wizard will appear.<ul> <li>Most default settings are fine for a basic setup.</li> <li>Optionally adjust configuration options (database, server settings, etc.).</li> </ul> </li> <li>Click Install Gitea.</li> <li>After installation, you\u2019ll be redirected to the login page.</li> <li>Register a new user \u2014 this will be your admin account.</li> </ol>"},{"location":"homelab/gitea-setup/#final-notes","title":"Final Notes","text":"<p>After Gitea is up and running:</p> <ul> <li>Create a Repository: From the Gitea dashboard.</li> <li>Clone the Repo Locally: <code>git clone https://git.yourdomain.com/your-user/your-repo.git</code></li> <li>Work with it Locally: Add, commit, and push changes just like with any Git remote.</li> </ul>"},{"location":"homelab/nginx-proxy-manager-setup/","title":"Nginx Proxy Manager Setup","text":"<p>This guide documents how I set up Nginx Proxy Manager with Docker Compose, DuckDNS for dynamic DNS and Let's Encrypt SSL certificates.</p>"},{"location":"homelab/nginx-proxy-manager-setup/#duckdns-openwrt-local-dns","title":"DuckDNS + OpenWrt Local DNS","text":"<p>Update DuckDNS to point to your VM's IP. Then configure OpenWrt to resolve the domain locally:</p> <ol> <li>Open OpenWrt: <code>Network &gt; DHCP and DNS &gt; General</code></li> <li>Under Addresses, add: <code>/yourdomain.duckdns.org/vm-ip</code></li> <li>Click <code>Save &amp; Apply</code></li> </ol> <p>This allows local devices to resolve the domain without going to the internet.</p>"},{"location":"homelab/nginx-proxy-manager-setup/#docker-compose-nginx-proxy-manager","title":"Docker Compose: Nginx Proxy Manager","text":"<ul> <li>Create directory:</li> </ul> <pre><code>mkdir nginx-proxy-manager/\ncd nginx-proxy-manager/\n$EDITOR docker-compose.yml\n</code></pre> <ul> <li>Edit <code>docker-compose.yml</code> file:</li> </ul> <pre><code>---\nservices:\n  service:\n    image: 'jc21/nginx-proxy-manager:latest'\n    container_name: nginx-proxy-manager\n    restart: unless-stopped\n    networks:\n      - proxy\n    ports:\n      - '80:80'\n      - '81:81'\n      - '443:443'\n    volumes:\n      - nginx-data:/nginx-data\n      - nginx-letsencrypt:/etc/letsencrypt\nnetworks:\n  proxy:\n    external: true\nvolumes:\n  nginx-data:\n  nginx-letsencrypt:\n</code></pre> <ul> <li>Create the Docker network:</li> </ul> <pre><code>docker network create proxy\n</code></pre> <ul> <li>Start the container:</li> </ul> <pre><code>docker compose up -d\n</code></pre> <p>Note</p> <p>Reusing the <code>proxy</code> network for other apps ensures they can be reverse-proxied by Nginx Proxy Manager without exposing internal ports to the host or external network. This simplifies networking, as all containers on the proxy network can be accessed internally by their container names (e.g., nginx-proxy-manager) and share the same network namespace, reducing configuration overhead and improving security.</p>"},{"location":"homelab/nginx-proxy-manager-setup/#initial-setup-via-web-ui","title":"Initial Setup via Web UI","text":"<ol> <li>Open browser: <code>http://&lt;vm-ip&gt;:81</code></li> <li>Log in with:<ul> <li>Email: <code>admin@example.com</code></li> <li>Password: <code>changeme</code></li> </ul> </li> <li>Set up the admin account:<ul> <li>Change the email to a personal one.</li> <li>Update the password when prompted.</li> </ul> </li> </ol>"},{"location":"homelab/nginx-proxy-manager-setup/#set-up-lets-encrypt-ssl-via-duckdns","title":"Set Up Let\u2019s Encrypt SSL via DuckDNS","text":"<ol> <li>Navigate to <code>SSL Certificates</code> &gt; <code>Add SSL Certificate</code></li> <li>Add Domain names:<ul> <li><code>yourdomain.duckdns.org</code></li> <li><code>*.yourdomain.duckdns.org</code></li> </ul> </li> <li>Use DNS Challenge:<ul> <li>DNS Provider: DuckDNS</li> <li>API Token: Your DuckDNS token</li> <li>Propagation Time: 30 (increase to 120 if errors occur)</li> </ul> </li> <li>Accept TOS and click Save</li> </ol> <p>Note</p> <ul> <li>If the DNS challenge fails, verify the DuckDNS token or increase propagation time to 120 seconds.</li> <li>Use the wildcard subdomain (<code>*.yourdomain.duckdns.org</code>) to simplify adding more apps (<code>proxy.yourdomain.duckdns.org</code>) without needing new SSL certificates.</li> </ul>"},{"location":"homelab/nginx-proxy-manager-setup/#create-proxy-host-reverse-proxy","title":"Create Proxy Host (Reverse Proxy)","text":"<ol> <li>Navigate to <code>Proxy Hosts</code> &gt; <code>Add Proxy Host</code></li> <li>Fill in:<ul> <li>Domain Names: <code>proxy.yourdomain.duckdns.org</code></li> <li>Scheme: <code>http</code></li> <li>Forward Hostname/IP: Container name (e.g., nginx-proxy-manager)</li> <li>Forward Port: <code>81</code> (or the port your app uses)</li> </ul> </li> <li>Optional settings:<ul> <li>Enable Websockets support, Block common exploits, or Asset caching as needed.</li> </ul> </li> <li>Go to SSL tab:<ul> <li>Select the created SSL certificate.</li> <li>Enable Force SSL and HTTP/2 Support.</li> <li>Click Save.</li> </ul> </li> </ol>"},{"location":"homelab/nginx-proxy-manager-setup/#test","title":"Test","text":"<p>Visit: <code>https://yourdomain.duckdns.org</code></p>"},{"location":"homelab/pihole-unbound-setup/","title":"Pi-hole Setup with Docker Compose and Unbound","text":"<p>This guide documents how I set up Pi-hole with Unbound using Docker Compose. The goal is to self-host DNS resolution and eliminate reliance on third-party DNS providers like Google or Cloudflare \u2014 improving privacy and blocking ads network-wide.</p>"},{"location":"homelab/pihole-unbound-setup/#create-project-directory","title":"Create Project Directory","text":"<p>Start by creating a directory to store config files:</p> <pre><code>mkdir pihole &amp;&amp; cd pihole\n</code></pre> <p>This folder will hold the <code>docker-compose.yml</code> and any volume data.</p>"},{"location":"homelab/pihole-unbound-setup/#docker-compose-setup","title":"Docker Compose Setup","text":"<p>I'm using the <code>mpgirro/pihole-unbound</code> Docker image, which combines Pi-hole with Unbound \u2014 a recursive DNS resolver \u2014 in a single container.</p> <p>Unbound queries root DNS servers directly, ensuring your DNS requests aren't logged or tracked by external providers.</p> <pre><code>---\nservices:\n  service:\n    container_name: pihole\n    image: mpgirro/pihole-unbound\n    hostname: ${HOSTNAME}\n    ports:\n      - \"53:53/tcp\"\n      - \"53:53/udp\"\n      - \"80:80/tcp\"\n      - \"443:443/tcp\"\n      - \"67:67/udp\"\n    environment:\n      - TZ=${TZ}\n      - FTLCONF_webserver_api_password=${FTLCONF_webserver_api_password}\n      - FTLCONF_dns_upstreams=127.0.0.1#5335\n      - FTLCONF_dns_dnssec=\"true\"\n      - FTLCONF_dns_listeningMode=single\n    networks:\n      proxy:\n      pihole_network:\n        ipv4_address: '192.168.0.150'\n    volumes:\n      - config_pihole:/etc/pihole\n    restart: unless-stopped\n\nvolumes:\n  config_pihole:\n\nnetworks:\n  proxy:\n    external: true\n  pihole_network:\n    driver: macvlan\n    driver_opts:\n      parent: ens18\n    ipam:\n      config:\n        - subnet: 192.168.0.0/24\n          gateway: 192.168.0.1\n</code></pre> <p>Note</p> <p>Make sure the external network <code>proxy</code> already exists, or create it using <code>docker network create proxy</code>.</p>"},{"location":"homelab/pihole-unbound-setup/#environment-variables","title":"Environment Variables","text":"<p>Set environment variables in the <code>.env</code> file:</p> <pre><code>HOSTNAME=pi-hole\nTZ=\"Region/Your_City\"\nFTLCONF_webserver_api_password=\"your-secure-password\"\n</code></pre> <p>Then start the container:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"homelab/pihole-unbound-setup/#ssl-via-nginx-proxy-manager-optional","title":"SSL via Nginx Proxy Manager (Optional)","text":"<p>To serve the Pi-hole web interface securely via HTTPS:</p> <ol> <li>Set up Nginx Proxy Manager.</li> <li>Add a new proxy host:<ul> <li>Domain: <code>dns.yourdomain.com</code></li> <li>Forward Hostname / IP: the IP of the Pi-hole container's host</li> <li>Forward Port: <code>80</code></li> </ul> </li> <li>Under the SSL tab:<ul> <li>Choose the existing certificate from the dropdown</li> <li>Enable Force SSL and optionally HTTP/2.</li> </ul> </li> </ol> <p>Now you can access Pi-hole via <code>https://dns.yourdomain.com</code>.</p>"},{"location":"homelab/pihole-unbound-setup/#configure-openwrt-to-use-pi-hole-dns","title":"Configure OpenWRT to Use Pi-hole DNS","text":"<p>To have your router forward all DNS queries to Pi-hole:</p> <ol> <li>Go to OpenWRT Web Interface</li> <li>Navigate to: <code>Network &gt; DHCP and DNS</code></li> <li>Under <code>DNS forwards</code>, enter the IP address assigned to the container (e.g. <code>192.168.0.150</code>)</li> <li>Click <code>Save &amp; Apply</code></li> </ol> <p>This ensures all devices using your router will query DNS through Pi-hole and Unbound.</p>"},{"location":"homelab/pihole-unbound-setup/#complete","title":"Complete","text":"<p>Everything is now set up for ad blocking and private DNS resolution. Just remember to update blocklists regularly and keep the Docker image up to date.</p>"},{"location":"linux/","title":"Linux Overview","text":""},{"location":"linux/disable-title-bar-i3-wm/","title":"Disable title bar in i3-wm","text":"<pre><code>vi ~/.config/i3/config\n\nfor_window [class=\"^.*\"] border pixel 1\n</code></pre>"},{"location":"linux/laptop-lid-sleep/","title":"Configure Laptop Lid Close Action and Screen Sleep Timeout","text":""},{"location":"linux/laptop-lid-sleep/#close-laptop-lid","title":"Close laptop lid","text":"<p>Edit <code>/etc/systemd/logind.conf</code>:</p> <ul> <li>Uncomment <code>HandleLidSwitch</code> and change <code>suspend</code> on <code>ignore</code>.</li> <li>Uncomment <code>HandleLidSwitchDocked</code>.</li> <li><code>systemctl restart systemd-logind.service</code></li> </ul>"},{"location":"linux/laptop-lid-sleep/#put-your-screen-to-sleep","title":"Put your screen to sleep","text":"<p>Edit <code>/etc/default/grub</code>:</p> <ul> <li>Add to <code>GRUB_CMDLINE_LINUX</code> this: <code>consoleblank=300</code> (After 300 seconds the screen will go to sleep)</li> <li><code>update-grub</code></li> </ul>"},{"location":"miscellaneous/","title":"Miscellaneous","text":""},{"location":"miscellaneous/github-markdown-alert/","title":"Using Alerts in GitHub Flavored Markdown (GFM) for Enhanced Documentation","text":"<p>I've recently discovered that GFM (also Obsidian and MkDocs) supports alerts which are a Markdown extension that you can use to emphasize important information.</p> <pre><code>&gt; [!NOTE]\n&gt; Test note\n</code></pre> <p>GFM supports five types of alerts:</p> <ul> <li>NOTE</li> <li>TIP</li> <li>IMPORTANT</li> <li>WARNING</li> <li>CAUTION</li> </ul> <p>Note</p> <p>Useful information that users should know.</p> <p>Tip</p> <p>Helpful advice that helps user to do things better or more easily.</p> <p>Important</p> <p>Key information users need to know to achieve their goal.</p> <p>Warning</p> <p>Information that needs user attention to avoid problems.</p> <p>Caution</p> <p>Advises about risks or negative outcomes of certain actions.</p>"},{"location":"networking/","title":"Networking","text":""},{"location":"networking/active-directory-nat-issues/","title":"Resolving Active Directory Issues in Proxmox with Dual NIC and Host-Only Networking","text":"<p>In a Proxmox-based lab, using only a single NAT network (via <code>vmbr0</code>) often leads to problems with Windows Server Active Directory and DNS, such as:</p> <ul> <li>Domain join failures</li> <li>Clients unable to resolve domain names</li> </ul> <p>These issues occur because NAT is not supported, not tested, and not recommended by Microsoft.</p>"},{"location":"networking/active-directory-nat-issues/#solution","title":"Solution","text":"<p>To fix this, each VM is configured with two virtual network interfaces:</p> Interface Bridge Purpose Gateway NIC 1 <code>vmbr0</code> NAT/internet access Yes NIC 2 <code>vmbr1</code> Internal (host-only) AD LAN None"},{"location":"networking/active-directory-nat-issues/#setting-up","title":"Setting up","text":"<ol> <li>Create a Host-Only (Internal) Bridge in Proxmox<ul> <li><code>node-name</code> -&gt; <code>Network</code> -&gt; <code>Create</code> -&gt; <code>Linux Bridge</code></li> <li>Name: <code>vmbr1</code></li> <li>IPv4: <code>192.168.100.1/24</code></li> <li>Everything else leave empty</li> </ul> </li> <li>Add 2 Network Interfaces to each VM<ul> <li><code>vmbr0</code> (default Proxmox bridge)</li> <li><code>vmbr1</code> (manual static IP for AD)</li> </ul> </li> <li>Configure Windows Server (Domain Controller) for <code>vmbr1</code> (Internal Bridge)<ul> <li>IP: <code>192.168.100.5</code></li> <li>Subnet Mask: <code>255.255.255.0</code></li> <li>Default Gateway: <code>192.168.100.1</code> (or leave blank)</li> <li>DNS: <code>192.168.100.5</code></li> </ul> </li> <li>Configure Windows 11 Client for <code>vmbr1</code> (Internal Bridge)<ul> <li>IP: <code>192.168.100.6</code></li> <li>Subnet Mask: <code>255.255.255.0</code></li> <li>Default Gateway: <code>192.168.100.1</code> (or leave blank)</li> <li>DNS: <code>192.168.100.5</code></li> </ul> </li> </ol> <p>Note</p> <ul> <li>Keep all domain-related traffic isolated.</li> <li>Don't set the default gateway on <code>vmbr1</code>, or clients may try to route internet traffic through the domain controller.</li> </ul>"},{"location":"networking/nic-teaming/","title":"NIC Teaming","text":"<p>NIC Teaming is a feature that allows to join multiple physical network cards into a single logical network card.</p> <p>Why may you need to combine multiple network adapters into a NIC Team?</p> <ul> <li>Increase throughput. For example, by joining two 1GB network cards into a NIC Team, you will get a 2Gbit/s bandwidth on a logical adapter;</li> <li>Manage network card load balancing. You can balance the network traffic across active NICs.</li> <li>Fault tolerance. If any of your network cards in a NIC Team fails, the rest cards take their functions and the connection with the server is not interrupted. Reduce single point of failure.</li> </ul>"},{"location":"unstructured-notes/","title":"Unstructured Notes","text":"<p>This folder contains small ideas, loose thoughts, and incomplete notes. I\u2019m working on better ways to manage and organize unstructured content \u2014 this is just a temporary solution.</p>"},{"location":"unstructured-notes/disk-naming-scheme-linux/","title":"Disk Naming Scheme on Linux","text":"<p>Disk devices are named using the pattern: <code>/dev/xxyz</code></p> <ul> <li><code>xx</code> \u2013 Device type (e.g. <code>sd</code> for SCSI/SATA, <code>nvme</code> for NVMe, <code>vd</code> for virtual disks)</li> <li><code>y</code> \u2013 Device letter (order of detection: a, b, c, etc.)</li> <li><code>z</code> \u2013 Partition number (e.g. 1, 2, 3)</li> </ul>"},{"location":"unstructured-notes/faster-clear/","title":"Faster <code>clear</code> command for the CLI","text":"<p>Replace the default clear command with an alias that directly sends ANSI escape codes to clear the terminal screen faster:</p> <pre><code>alias clear='printf \"\\033[H\\033[2J\"'\nalias c='printf \"\\033[H\\033[2J\"'\n</code></pre> <p>Explanation:</p> <ul> <li><code>\\033[H</code> \u2013 moves the cursor to the top-left corner.</li> <li><code>\\033[2J</code> \u2013 clears the entire screen.</li> </ul> <p>The regular clear command is an actual executable, which adds a small delay. Using printf with escape codes is faster because it avoids that overhead.</p>"},{"location":"unstructured-notes/fields-and-delimiters/","title":"What are fields and delimiters?","text":"<ul> <li>Delimiter is a character or sequence of characters that separates fields</li> <li>Field is the stuff that gets separated</li> <li>Some common delimiters are commas, semicolons, quotes, spaces, tabs, etc.</li> </ul>"},{"location":"unstructured-notes/func-in-sh-scripts/","title":"Why put code into a function in shell scripts?","text":"<p>Putting code into functions makes it easier to manage, especially when using editors like <code>vi</code>. One big benefit of doing this is that I can quickly cut and paste entire functions using commands like <code>dap</code> in <code>vi</code>, which deletes a full function block. This makes it easy to move or reuse the code elsewhere.</p> <p>Using functions help by:</p> <ul> <li>Making code modular and reusable</li> <li>Reducing the need to depend on external scripts</li> <li>Keeping everything in one place, which simplifies maintenance</li> </ul>"},{"location":"unstructured-notes/hard-soft-links/","title":"Hard and Symbolic Links","text":"<ul> <li>Hard Link points directly to the same inode as the original file</li> <li>Symbolic (soft) link is a special file that points to the pathname of another file</li> </ul>"},{"location":"unstructured-notes/hard-soft-links/#hard-link-limitations","title":"Hard link limitations:","text":"<ul> <li>Cannot link to a file on a different filesystem (must be on the same disk/partition)</li> <li>Cannot link to a directory</li> </ul>"},{"location":"unstructured-notes/hard-soft-links/#behavior-differences","title":"Behavior differences:","text":"<p>If the original file was deleted, a hard link will still access the data because it shares the same inode. In contrast, a symbolic link will break and return an error, since it points to a path that no longer exists.</p>"},{"location":"unstructured-notes/inode/","title":"Inode","text":"<p>An inode is a data structure that stores all metadata about a file except its name. The number of inodes limits how many files and directories a filesystem can hold.</p> <p>It contains:</p> <ul> <li>File size</li> <li>Device ID</li> <li>User ID and Group ID</li> <li>Permissions</li> <li>Timestamps</li> <li>Data location (not the filepath)</li> </ul>"},{"location":"unstructured-notes/pass-data-in-program/","title":"Primary ways to pass data into a program","text":"<ul> <li>Set environment variables</li> <li>Using arguments to the command</li> <li>Reading input from standard input</li> <li>Open a file to get the data</li> <li>Fetching from a webpage</li> </ul>"},{"location":"unstructured-notes/why-partition-system-important/","title":"Why Partitioning Is Important for Security?","text":"<p>Partitioning allows you to apply specific security controls to different parts of the filesystem. For example, directories like <code>/tmp</code> or <code>/var</code> can be mounted with options like <code>noexec</code> (to block script execution) or <code>nosuid</code> (to prevent privilege escalation).</p> <p>It also reduces the impact of a compromise \u2014 isolating data makes it harder for an attacker to affect the whole system.</p> <p>Additionally, when encrypting the full system, <code>/boot</code> must stay unencrypted, so it needs to be on a separate partition.</p>"},{"location":"unstructured-notes/why-partition-system-important/#other-benefits","title":"Other Benefits","text":"<ul> <li>Prevents one directory (like <code>/var</code> or <code>/tmp</code>) from filling up the root filesystem and crashing the system</li> <li>Makes it easier to back up and protect user data by isolating /home</li> <li>Allows using optimized filesystems like <code>tmpfs</code> for <code>/tmp</code>, which stores temporary data in RAM and clears it on reboot</li> </ul>"},{"location":"virtualization/","title":"Virtualization","text":""},{"location":"virtualization/container-vs-vm/","title":"Containers vs Virtual Machines: Key Differences and Performance","text":"<p>The key difference is that, instead of virtualizing hardware, containers only virtualize the OS (kernel). All apps or containers are run by a single kernel.</p> <p>Containers are generally lightweight and small in size, for these reasons they perform better than VMs.</p> <p>As with VMs, they are much bigger in size, generally in gigabytes, and take longer to run than containers.</p>"},{"location":"virtualization/proxmox-storage/","title":"Understanding Proxmox Storage: local vs local-lvm","text":"<p>With the default Proxmox setup, <code>local</code> stores the ISO images and container templates, and <code>local-lvm</code> stores the installed VMs and containers themselves. I would not recommend deleting <code>local-lvm</code> in order to resize <code>local</code>. That removes the ability to take snapshots of each VM and container, which is one of the most beneficial reasons to use a Type 1 hypervisor in the first place.</p>"},{"location":"windows/","title":"Windows","text":""},{"location":"windows/windows-server-licensing-error/","title":"Fix VMware VM Windows Server Install Error","text":"<p>When I was trying to power on the VM, I met an error telling me that Windows can't find Microsoft Software Licensing Terms.</p> <p>What's happened is that when you first create a VM, VMware adds floppy drive, which Windows thinks contains activation file (or something like it), which it doesn't, so the installation will fail all the time.</p> <p>To solve this problem,</p> <ol> <li>Start the VM</li> <li>Wait until Windows starts to load</li> <li>Shut the VM down</li> <li>Remove floppy disk from the config</li> </ol>"}]}